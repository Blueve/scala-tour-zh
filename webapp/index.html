<!DOCTYPE html>
<html lang="en">
    <head>
        <meta name="generator" content="HTML Tidy for HTML5 (experimental) for Windows https://github.com/w3c/tidy-html5/tree/c63cc39">
        <meta charset="utf-8">
        <meta name="viewport" content="width=1024">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <title>
            Scala Tour
        </title>
        <meta name="description" content="impress.js is a presentation tool based on the power of CSS3 transforms and transitions in modern browsers and inspired by the idea behind prezi.com.">
        <meta name="author" content="Bartek Szopka">
        <link href="css/impress-demo.css" rel="stylesheet">
        <link href="css/bootstrap.css" rel="stylesheet">
        <link href="css/bootstrap-responsive.css" rel="stylesheet">
        <link href="css/codemirror.css" rel="stylesheet">
        <link href="css/solarized.css" rel="stylesheet">
        <link href="css/scala-tour.css" rel="stylesheet">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="apple-touch-icon" href="apple-touch-icon.png">
    </head>
    <body id="body" class="impress-not-supported onload">
        <div class="navbar navbar-fixed-top" style="pointer-events: auto;">
            <div class="navbar-inner">
                <div class="container" style="width:1020px">
                    <a id="logo" class="brand" href="#/welcome"><img src="img/logo.png">Scala 指南</a>
                    <ul class="nav">
                        <li class="">
                            <a href="#/glance">概览</a>
                        </li>
                        <li class="">
                            <a href="#/about">About</a>
                        </li>
                    </ul><a class="lang" href="http://zh.scala-tour.com/" title="中文">中文</a> <a class="lang" href="http://www.scala-tour.com/" title="English">English</a>
                </div>
            </div>
        </div>
        <div id="brower-not-support" class="alert fallback-message">
            <p>
                <strong>Warning!</strong> Your browser <b>doesn't support the features required</b>.
            </p>
            <p>
                For the best experience please use the latest <b>Chrome</b>, <b>Safari</b> or <b>Firefox</b> browser.
            </p>
        </div>
        <div id="impress">
            <div id="welcome" class="step" data-x="-3500" data-y="-2000">
                <h1>
                    <span class="scala-red">Scala</span> 指南
                </h1>
                <p>
                    Explore the Scala programming lanaguage.
                </p>
            </div>
            <div id="hello-wolrd" class="step slide" data-x="-2000" data-y="-2000">
                <div class="row-fluid">
                    <div class="span8">
                        <div class="workspace">
                            <div class="controls">
                                <button type="button" class="run btn btn-primary" title="Compile and Run">Run</button>
                            </div>
                            <div class="workspace-top">
                                <div class="workspace-editor">
                                    <form>
                                        <textarea class="editor" spellcheck="false">
println("hello world")
</textarea>
                                    </form>
                                </div>
                            </div>
                            <div class="workspace-bottom">
                                <div class="output"></div>
                            </div>
                        </div>
                    </div>
                    <div class="span4">
                        <h2>
                            Hello World
                        </h2>
                        <p>
                            <b>Scala</b> is a popular <b>functional</b>/<b>object-oriented</b> programming language built on top of the <b>Java virtual machine (JVM)</b>.
                        </p>
                        <p>
                            The tour will help you to know the prowerful features about Scala.And you could learn how to use them effectively through experimentation.
                        </p>
                        <p>
                            The tour is interactive. Click the <b>Run</b> button now to compile and run the program on a remote server. The result is displayed below the code. You can edit it and run your own code.
                        </p>
                        <p>
                            Use a spacebar or arrow keys to navigate
                        </p>
                        <p>
                            <b>Ready? Go</b>
                        </p>
                    </div>
                </div>
            </div>
            <div id="glance" class="step" data-x="0" data-y="0" data-scale="8"></div>
            <div id="basics" class="step" data-x="0" data-y="-2000" data-scale="2">
                <h2 style="font-size: 200px;">
                    基本
                </h2>
            </div>
            <div class="step slide deeply" data-x="-2000" data-y="-2000" data-z="-3000">
                <div class="row-fluid">
                    <div class="span8">
                        <div class="workspace">
                            <div class="controls">
                                <button type="button" class="run btn btn-primary" title="Compile and Run">Run</button>
                            </div>
                            <div class="workspace-top">
                                <div class="workspace-editor">
                                    <form>
                                        <textarea class="editor" spellcheck="false">
var helloWorld = "hello" + " world" 
println(helloWorld)

val again = " again" 
helloWorld = helloWorld + again
println(helloWorld)
</textarea>
                                    </form>
                                </div>
                            </div>
                            <div class="workspace-bottom">
                                <div class="output"></div>
                            </div>
                        </div>
                    </div>
                    <div class="span4">
                        <h2>
                            表达式和值
                        </h2>
                        <p>
                            在Scala中，几乎所有的语言元素都是表达式。println("hello wolrd")是一个表达式， "hello"+" world"也是一个表达式。
                        </p>
                        <p>
                            可以通过val定义一个常量，亦可以通过var定义一个变量。推荐多使用常量。
                        </p>
                    </div>
                </div>
            </div>
            <div class="step slide deeply" data-x="-500" data-y="-2000" data-z="-3000">
                <div class="row-fluid">
                    <div class="span8">
                        <div class="workspace">
                            <div class="controls">
                                <button type="button" class="run btn btn-primary" title="Compile and Run">Run</button>
                            </div>
                            <div class="workspace-top">
                                <div class="workspace-editor">
                                    <form>
                                        <textarea class="editor" spellcheck="false">
def square(a: Int) = a * a

def squareWithBlock(a: Int) = {
    a * a
}

val squareVal = (a: Int) =&gt; a * a

def addOne(f: Int =&gt; Int, arg: Int) = f(arg) + 1

println("square(2):" + square(2))
println("squareWithBlock(2):" + squareWithBlock(2))
println("squareVal(2):" + squareVal(2))
println("addOne(squareVal,2):" + addOne(squareVal, 2))
</textarea>
                                    </form>
                                </div>
                            </div>
                            <div class="workspace-bottom">
                                <div class="output"></div>
                            </div>
                        </div>
                    </div>
                    <div class="span4">
                        <h2>
                            函数是一等公民
                        </h2>
                        <p>
                            可以使用def来定义一个函数。函数体是一个表达式。
                        </p>
                        <p>
                            使用Block表达式的时候，默认最后一行的返回是返回值，无需显示指定。
                        </p>
                        <p>
                            函数还可以像值一样，赋值给var或val。因此他也可以作为参数传给另一个函数。
                        </p>
                    </div>
                </div>
            </div>
            <div class="step slide deeply" data-x="1000" data-y="-2000" data-z="-3000">
                <div class="row-fluid">
                    <div class="span8">
                        <div class="workspace">
                            <div class="controls">
                                <button type="button" class="run btn btn-primary" title="Compile and Run">Run</button>
                            </div>
                            <div class="workspace-top">
                                <div class="workspace-editor">
                                    <form>
                                        <textarea class="editor" spellcheck="false">
import scala.reflect.io.File
import java.util.Scanner

def withScanner(f: File, op: Scanner =&gt; Unit) = {
    val scanner = new Scanner(f.bufferedReader)
    try {
        op(scanner)
    } finally {
        scanner.close()
    }
}

withScanner(File("/proc/self/stat"),
    scanner =&gt; println("pid is " + scanner.next()))
</textarea>
                                    </form>
                                </div>
                            </div>
                            <div class="workspace-bottom">
                                <div class="output"></div>
                            </div>
                        </div>
                    </div>
                    <div class="span4">
                        <h2>
                            借贷模式
                        </h2>
                        <p>
                            由于函数可以像值一样作为参数传递，所以可以方便的实现借贷模式。
                        </p>
                        <p>
                            这个例子是从/proc/self/stat文件中读取当前进程的pid。
                        </p>
                        <p>
                            withScanner封装了try-finally块，所以调用者不用再close。
                        </p>
                        <p>
                            注：当表达式没有返回值时，默认返回Unit。
                        </p>
                    </div>
                </div>
            </div>
            <div class="step slide deeply" data-x="2500" data-y="-2000" data-z="-3000">
                <div class="row-fluid">
                    <div class="span8">
                        <div class="workspace">
                            <div class="controls">
                                <button type="button" class="run btn btn-primary" title="Compile and Run">Run</button>
                            </div>
                            <div class="workspace-top">
                                <div class="workspace-editor">
                                    <form>
                                        <textarea class="editor" spellcheck="false">
val logEnable = false

def log(msg: String) =
    if (logEnable) println(msg)

val MSG = "programing is running"

log(MSG + 1 / 0)
</textarea>
                                    </form>
                                </div>
                            </div>
                            <div class="workspace-bottom">
                                <div class="output"></div>
                            </div>
                        </div>
                    </div>
                    <div class="span4">
                        <h2>
                            按名称传递参数
                        </h2>
                        <p>
                            这个例子演示了按名称传递参数，最末有1/0这个明显会产生异常的计算，运行该程序会产生异常。
                        </p>
                        <p>
                            试着将def log(msg: String)修改为def log(msg: =&gt; String)。由按值传递修改为按名称传递后将不会产生异常。
                        </p>
                        <p>
                            因为log函数的参数是按名称传递，参数会等到真正访问的时候才会计算，由于logEnable = false，所以被跳过。
                        </p>
                        <p>
                            按名称传递参数可以减少不必要的计算和异常。
                        </p>
                    </div>
                </div>
            </div>
            <div class="step slide deeply" data-x="4000" data-y="-2000" data-z="-3000">
                <div class="row-fluid">
                    <div class="span8">
                        <div class="workspace">
                            <div class="controls">
                                <button type="button" class="run btn btn-primary" title="Compile and Run">Run</button>
                            </div>
                            <div class="workspace-top">
                                <div class="workspace-editor">
                                    <form>
                                        <textarea class="editor" spellcheck="false">
class Persion(val firstName: String, val lastName: String) {

    private var _age = 0
    def age = _age
    def age_=(newAge: Int) = _age = newAge

    def fullName() = firstName + " " + lastName

    override def toString() = fullName()
}

val obama: Persion = new Persion("Barack", "Obama")

println("Persion: " + obama)
println("firstName: " + obama.firstName)
println("lastName: " + obama.lastName)
obama.age_=(51)
println("age: " + obama.age())
</textarea>
                                    </form>
                                </div>
                            </div>
                            <div class="workspace-bottom">
                                <div class="output"></div>
                            </div>
                        </div>
                    </div>
                    <div class="span4">
                        <h2>
                            类定义
                        </h2>
                        <p>
                            可以用class关键字来定义类。并通过new来创建类。
                        </p>
                        <p>
                            在定义类时可以定义字段，如firstName，lastName。这样做还可以自动生成构造函数。
                        </p>
                        <p>
                            可以在类中通过def定义函数。var和val定义字段。
                        </p>
                        <p>
                            函数名是任何字符如+,-,*,/。
                        </p>
                        <p>
                            例子中obama.age_=(51)的函数调用，可以简化为obama.age = 51 。
                        </p>
                        <p>
                            obama.age()的函数调用，可以省略小括号，简化为obama.age。
                        </p>
                    </div>
                </div>
            </div>
            <div class="step slide deeply" data-x="5500" data-y="-2000" data-z="-3000">
                <div class="row-fluid">
                    <div class="span8">
                        <div class="workspace">
                            <div class="controls">
                                <button type="button" class="run btn btn-primary" title="Compile and Run">Run</button>
                            </div>
                            <div class="workspace-top">
                                <div class="workspace-editor">
                                    <form>
                                        <textarea class="editor" spellcheck="false">
def withClose(closeAble: { def close(): Unit }, op: { def close(): Unit } =&gt; Unit) {
    try {
        op(closeAble)
    } finally {
        closeAble.close()
    }
}

class Connection {
    def close() = println("close Connection")
}

val conn: Connection = new Connection()
withClose(conn, conn =&gt;
    println("do something with Connection"))
</textarea>
                                    </form>
                                </div>
                            </div>
                            <div class="workspace-bottom">
                                <div class="output"></div>
                            </div>
                        </div>
                    </div>
                    <div class="span4">
                        <h2>
                            鸭子类型
                        </h2>
                        <p>
                            走起来像鸭子，叫起来像鸭子，就是鸭子。
                        </p>
                        <p>
                            这个例子中使用{ def close(): Unit }作为参数类型。因为任何含有close()的函数的类都可以作为参数。
                        </p>
                        <p>
                            不必使用继承这种不够灵活的特性。
                        </p>
                    </div>
                </div>
            </div>
            <div class="step slide deeply" data-x="7000" data-y="-2000" data-z="-3000">
                <div class="row-fluid">
                    <div class="span8">
                        <div class="workspace">
                            <div class="controls">
                                <button type="button" class="run btn btn-primary" title="Compile and Run">Run</button>
                            </div>
                            <div class="workspace-top">
                                <div class="workspace-editor">
                                    <form>
                                        <textarea class="editor" spellcheck="false">
def withClose(closeAble: { def close(): Unit })(op: { def close(): Unit } =&gt; Unit) {
    try {
        op(closeAble)
    } finally {
        closeAble.close()
    }
}

class Connection {
    def close() = println("close Connection")
}

val conn: Connection = new Connection()
withClose(conn)(conn =&gt;
    println("do something with Connection"))
</textarea>
                                    </form>
                                </div>
                            </div>
                            <div class="workspace-bottom">
                                <div class="output"></div>
                            </div>
                        </div>
                    </div>
                    <div class="span4">
                        <h2>
                            柯里化
                        </h2>
                        <p>
                            这个例子和上面的功能相同。不同的是使用了柯里化（Currying)的技术。
                        </p>
                        <p>
                            def add(x:Int, y:Int) = x + y 是普通的函数
                        </p>
                        <p>
                            def add(x:Int) = (y:Int) =&gt; x + y 是柯里化后的函数，相当于返回一个匿名函数表达式。
                        </p>
                        <p>
                            def add(x:Int)(y:Int) = x + y 是上面的简化写法
                        </p>
                        <p>
                            柯里化可以让我们构造出更像原生语言提供的功能的代码
                        </p>
                        <p>
                            例子中的withclose(...)(...)换成withclose(...){...}
                        </p>
                        <p>
                            是否和java中的synchronized关键字用法很像？
                        </p>
                    </div>
                </div>
            </div>
            <div class="step slide deeply" data-x="8500" data-y="-2000" data-z="-3000">
                <div class="row-fluid">
                    <div class="span8">
                        <div class="workspace">
                            <div class="controls">
                                <button type="button" class="run btn btn-primary" title="Compile and Run">Run</button>
                            </div>
                            <div class="workspace-top">
                                <div class="workspace-editor">
                                    <form>
                                        <textarea class="editor" spellcheck="false">
def withClose[A &lt;: { def close(): Unit }, B](closeAble: A)(op: A =&gt; B) {
    try {
        op(closeAble)
    } finally {
        closeAble.close()
    }
}

class Connection {
    val msg = "123456"
    def close() = println("close Connection")
}

val conn: Connection = new Connection()
val msg = withClose(conn) { conn =&gt;
    {
        println("do something with Connection")
        conn.msg
    }
}
    
println(msg)
</textarea>
                                    </form>
                                </div>
                            </div>
                            <div class="workspace-bottom">
                                <div class="output"></div>
                            </div>
                        </div>
                    </div>
                    <div class="span4">
                        <h2>
                            范型
                        </h2>
                        <p>
                            上面的例子可以使用泛型变得更简洁更灵活。
                        </p>
                        <p>
                            试着将val msg = "123456"修改为val msg = 123456。
                        </p>
                        <p>
                            虽然msg由String类型变为Int类型，但是由于使用了泛型，代码依旧可以正常运行。
                        </p>
                    </div>
                </div>
            </div>
            <div class="step slide deeply" data-x="10000" data-y="-2000" data-z="-3000">
                <div class="row-fluid">
                    <div class="span8">
                        <div class="workspace">
                            <div class="controls">
                                <button type="button" class="run btn btn-primary" title="Compile and Run">Run</button>
                            </div>
                            <div class="workspace-top">
                                <div class="workspace-editor">
                                    <form>
                                        <textarea class="editor" spellcheck="false">
trait ForEachAble[A] {
    def iterator: java.util.Iterator[A]
    def foreach(f: A =&gt; Unit) = {
        val iter = iterator
        while (iter.hasNext)
            f(iter.next)
    }
}

trait JsonAble {
    override def toString() =
        scala.util.parsing.json.JSONFormat.defaultFormatter(this)
}

val list = new java.util.ArrayList[Int]() with ForEachAble[Int]
list.add(1); list.add(2)

list.foreach(x =&gt; println(x))
println("Json: " + list.toString())
</textarea>
                                    </form>
                                </div>
                            </div>
                            <div class="workspace-bottom">
                                <div class="output"></div>
                            </div>
                        </div>
                    </div>
                    <div class="span4">
                        <h2>
                            Traits
                        </h2>
                        <p>
                            Traits就像是有函数体的Interface。使用with关键字来混入。
                        </p>
                        <p>
                            这个例子是给java.util.ArrayList添加了foreach的功能。
                        </p>
                        <p>
                            试着再在后面加上with JsonAble，给list添加toJson的能力
                        </p>
                    </div>
                </div>
            </div>
            <div id="advanced" class="step" data-x="-3000" data-y="0" data-scale="2">
                <h2 style="font-size: 200px;">
                    函数式编程
                </h2>
            </div>
            <div class="step slide deeply" data-x="-2000" data-y="-500" data-z="-3000">
                <div class="row-fluid">
                    <div class="span8">
                        <div class="workspace">
                            <div class="controls">
                                <button type="button" class="run btn btn-primary" title="Compile and Run">Run</button>
                            </div>
                            <div class="workspace-top">
                                <div class="workspace-editor">
                                    <form>
                                        <textarea class="editor" spellcheck="false">
def fibonacci(in: Any): Int = in match {
    case 0 =&gt; 0
    case 1 =&gt; 1
    case n: Int =&gt; fibonacci(n - 1) + fibonacci(n - 2)
    case _ =&gt; 0
}

println(fibonacci(3))
</textarea>
                                    </form>
                                </div>
                            </div>
                            <div class="workspace-bottom">
                                <div class="output"></div>
                            </div>
                        </div>
                    </div>
                    <div class="span4">
                        <h2>
                            模式匹配
                        </h2>
                        <p>
                            模式匹配是类似switch-case特性，但更加灵活；也类似if-else，但更加简约。
                        </p>
                        <p>
                            这个例子展示的使用用模式匹配实现斐波那契。
                        </p>
                        <p>
                            使用case来匹配参数，如果case _，则可以匹配任何参数。
                        </p>
                        <p>
                            这个例子有所不足，当输入负数时，会无限循环。
                        </p>
                        <p>
                            可以在case后添加if语句判断，将case n: Int 修改为 case n: Int if (n &gt; 1)即可。
                        </p>
                        <p>
                            可以在case _ 前加上 case n: String =&gt; fibonacci(n.toInt)，使之匹配字符串类型。
                        </p>
                        <p>
                            在最后添加 println(fibonacci(-3))；println(fibonacci("3"))；来检查刚刚修改的效果。
                        </p>
                    </div>
                </div>
            </div>
            <div class="step slide deeply" data-x="-500" data-y="-500" data-z="-3000">
                <div class="row-fluid">
                    <div class="span8">
                        <div class="workspace">
                            <div class="controls">
                                <button type="button" class="run btn btn-primary" title="Compile and Run">Run</button>
                            </div>
                            <div class="workspace-top">
                                <div class="workspace-editor">
                                    <form>
                                        <textarea class="editor" spellcheck="false">
abstract class Expr

case class FibonacciExpr(n: Int) extends Expr {
  require(n &gt;= 0)
}

case class SumExpr(a: Expr, b: Expr) extends Expr

def value(in: Expr): Int = in match {
  case FibonacciExpr(0) =&gt; 0
  case FibonacciExpr(1) =&gt; 1
  case FibonacciExpr(n) =&gt; value(SumExpr(FibonacciExpr(n - 1), FibonacciExpr(n - 2)))
  case SumExpr(a, b) =&gt; value(a) + value(b)
  case _ =&gt; 0
}
println(value(FibonacciExpr(3)))
</textarea>
                                    </form>
                                </div>
                            </div>
                            <div class="workspace-bottom">
                                <div class="output"></div>
                            </div>
                        </div>
                    </div>
                    <div class="span4">
                        <h2>
                            Case Class
                        </h2>
                        <p>
                            case class 顾名思义就是为case语句专门设计的类。
                        </p>
                        <p>
                            在普通类的基础上添加了和类名一直的工厂方法，
                        </p>
                        <p>
                            还添加了hashcode,equals和toString方法。
                        </p>
                        <p>
                            试试最后添加 println(Sum(1,2)) 。
                        </p>
                        <p>
                            由于使用了require(n &gt;= 0)来检验参数，尝试使用负数，会抛出异常。
                        </p>
                    </div>
                </div>
            </div>
            <div class="step slide deeply" data-x="1000" data-y="-500" data-z="-3000">
                <div class="row-fluid">
                    <div class="span8">
                        <div class="workspace">
                            <div class="controls">
                                <button type="button" class="run btn btn-primary" title="Compile and Run">Run</button>
                            </div>
                            <div class="workspace-top">
                                <div class="workspace-editor">
                                    <form>
                                        <textarea class="editor" spellcheck="false">
val list = List(1, 2, 3, 4)

def containsOdd(list: List[Int]): Boolean = {
  for (i &lt;- list) {
    if (i % 2 == 1)
      return true;
  }
  return false;
}

println("list containsOdd by for loop:" + containsOdd(list))

println("list containsOdd by funtional:" + list.exists(_ % 2 == 1))
</textarea>
                                    </form>
                                </div>
                            </div>
                            <div class="workspace-bottom">
                                <div class="output"></div>
                            </div>
                        </div>
                    </div>
                    <div class="span4">
                        <h2>
                            函数式的威力
                        </h2>
                        <p>
                            这个例子是判断一个List中是否含有奇数。
                        </p>
                        <p>
                            第一行到倒数第二行是使用for循环的过程式编程解决。最后一行是通过函数式编程解决。
                        </p>
                        <p>
                            通过将函数作为参数，可以使程序极为简洁。其中 _ % 2 == 1 是 (x: Int) =&gt; x % 2 == 的简化写法。
                        </p>
                        <p>
                            相比于Ruby等动态语言,这威力来自于科学而不是魔法
                        </p>
                    </div>
                </div>
            </div>
            <div class="step slide deeply" data-x="2500" data-y="-500" data-z="-3000">
                <div class="row-fluid">
                    <div class="span8">
                        <div class="workspace">
                            <div class="controls">
                                <button type="button" class="run btn btn-primary" title="Compile and Run">Run</button>
                            </div>
                            <div class="workspace-top">
                                <div class="workspace-editor">
                                    <form>
                                        <textarea class="editor" spellcheck="false">
val file = List("warn 2013 msg", "warn 2012 msg", "error 2013 msg", "warn 2013 msg")

println("cat file | grep 'warn' | grep '2013' | wc : " 
    + file.filter(_.contains("warn")).filter(_.contains("2013")).size)
</textarea>
                                    </form>
                                </div>
                            </div>
                            <div class="workspace-bottom">
                                <div class="output"></div>
                            </div>
                        </div>
                    </div>
                    <div class="span4">
                        <h2>
                            函数式真正的威力
                        </h2>
                        <p>
                            函数式除了能简化代码外，更重要的是他关注的是Input和Output，函数本身没有副作用。
                        </p>
                        <p>
                            就是Unix pipeline一样，简单的命令可以组合在一起。
                        </p>
                        <p>
                            List的filter方法接受一个过滤函数，返回一个新的List
                        </p>
                        <p>
                            如果你喜欢Unix pipeline的方式，你一定也会喜欢函数式编程。
                        </p>
                        <p>
                            这个例子是用函数式的代码模拟“cat file | grep 'warn' | grep '2013' | wc”的行为。
                        </p>
                    </div>
                </div>
            </div>
            <div class="step slide deeply" data-x="4000" data-y="-500" data-z="-3000">
                <div class="row-fluid">
                    <div class="span8">
                        <div class="workspace">
                            <div class="controls">
                                <button type="button" class="run btn btn-primary" title="Compile and Run">Run</button>
                            </div>
                            <div class="workspace-top">
                                <div class="workspace-editor">
                                    <form>
                                        <textarea class="editor" spellcheck="false">
val file = List("warn 2013 msg", "warn 2012 msg", "error 2013 msg", "warn 2013 msg")

def wordcount(str: String): Int = str.split(" ").count("msg" == _)
  
val num = file.map(wordcount).reduceLeft(_ + _)

println("wordcount:" + num)
</textarea>
                                    </form>
                                </div>
                            </div>
                            <div class="workspace-bottom">
                                <div class="output"></div>
                            </div>
                        </div>
                    </div>
                    <div class="span4">
                        <h2>
                            Word Count
                        </h2>
                        <p>
                            Word Count是一个MapReduce的一个经典示例。巧合的是，使用函数式的编程法，用类似MapReduce的方法实现word count也是最直观的。
                        </p>
                        <p>
                            这个例子介绍了List的两个重要的高阶方法map和reduceLeft。
                        </p>
                        <p>
                            List的map方法接受一个转换函数，返回一个经过转换的List。该例子中会转换为[1,1,1,1]
                        </p>
                        <p>
                            List的reduceLeft方法接受一个合并函数，依次遍历合并。第一个参数是合并后的值，第二个参数是下一个需要合并的值。
                        </p>
                        <p>
                            将reduceLeft(_ + _)修改为foldLeft(0)(_ + _)。foldLeft比将reduceLeft更常用，因为他可以提供一个初始参数。
                        </p>
                        <p>
                            Map和foldLeft可以代替大部分需要for循环的操作，并且使代码更清晰
                        </p>
                    </div>
                </div>
            </div>
            <div class="step slide deeply" data-x="5500" data-y="-500" data-z="-3000">
                <div class="row-fluid">
                    <div class="span8">
                        <div class="workspace">
                            <div class="controls">
                                <button type="button" class="run btn btn-primary" title="Compile and Run">Run</button>
                            </div>
                            <div class="workspace-top">
                                <div class="workspace-editor">
                                    <form>
                                        <textarea class="editor" spellcheck="false">
val file = List("warn 2013 msg", "warn 2012 msg", "error 2013 msg", "warn 2013 msg")

def wordcount(str: String): Int = str.split(" ").count("msg" == _)

def foldLeft(list: List[Int])(init: Int)(f: (Int, Int) =&gt; Int): Int = {
  list match {
    case List() =&gt; init
    case head :: tail =&gt; foldLeft(tail)(f(init, head))(f)
  }
}

val num = foldLeft(file.map(wordcount))(0)(_ + _)

println("wordcount:" + num)
</textarea>
                                    </form>
                                </div>
                            </div>
                            <div class="workspace-bottom">
                                <div class="output"></div>
                            </div>
                        </div>
                    </div>
                    <div class="span4">
                        <h2>
                            尾递归
                        </h2>
                        <p>
                            这个例子是用尾递归实现foldLeft。尾递归是递归的一种，特点在于会在函数的最末调用自身。
                        </p>
                        <p>
                            当用List做match case时。可以使用 :: 来解构。返回第一个元素head，和剩余元素tail。
                        </p>
                        <p>
                            尾递归会在编译期优化，因此不用担心一般递归造成的栈溢出问题。
                        </p>
                    </div>
                </div>
            </div>
            <div class="step slide deeply" data-x="7000" data-y="-500" data-z="-3000">
                <div class="row-fluid">
                    <div class="span8">
                        <div class="workspace">
                            <div class="controls">
                                <button type="button" class="run btn btn-primary" title="Compile and Run">Run</button>
                            </div>
                            <div class="workspace-top">
                                <div class="workspace-editor">
                                    <form>
                                        <textarea class="editor" spellcheck="false">
val file = List("warn 2013 msg", "warn 2012 msg", "error 2013 msg", "warn 2013 msg")

def wordcount(str: String): Int = str.split(" ").count("msg" == _)

val counts =
  for (line &lt;- file)
    yield wordcount(line)

val num = counts.reduceLeft(_ + _)

println("wordcount:" + num)
</textarea>
                                    </form>
                                </div>
                            </div>
                            <div class="workspace-bottom">
                                <div class="output"></div>
                            </div>
                        </div>
                    </div>
                    <div class="span4">
                        <h2>
                            更强大的For
                        </h2>
                        <p>
                            循环语句是指令式编程的特产，Scala对其加以改进，成为适应函数式风格的利器。
                        </p>
                        <p>
                            For循环也是有返回值的，其返回是一个List。在每一轮迭代中加入yield，yield后的值可以加入到List中。
                        </p>
                        <p>
                            这个例子是使用for循环代替map函数。
                        </p>
                    </div>
                </div>
            </div>
            <div class="step slide deeply" data-x="8500" data-y="-500" data-z="-3000">
                <div class="row-fluid">
                    <div class="span8">
                        <div class="workspace">
                            <div class="controls">
                                <button type="button" class="run btn btn-primary" title="Compile and Run">Run</button>
                            </div>
                            <div class="workspace-top">
                                <div class="workspace-editor">
                                    <form>
                                        <textarea class="editor" spellcheck="false">
def getProperty(name: String): Option[String] = {
  val value = System.getProperty(name)
  if (value != null) Some(value) else None
}

val osName = getProperty("os.name")

osName match {
  case Some(value) =&gt; println(value)
  case _ =&gt; println("none")
}

println(osName.getOrElse("none"))
</textarea>
                                    </form>
                                </div>
                            </div>
                            <div class="workspace-bottom">
                                <div class="output"></div>
                            </div>
                        </div>
                    </div>
                    <div class="span4">
                        <h2>
                            Option
                        </h2>
                        <p>
                            NullException是Java中最常见的异常，要想避免他只有不断检查null。Scala提供了Option机制来解决。
                        </p>
                        <p>
                            这个例子包装了可能返回null的getProperty方法，使其返回一个Option。
                        </p>
                        <p>
                            这样就可以不再漫无目的地null检查。只要Option类型的值即可。
                        </p>
                        <p>
                            使用pattern match来检查是常见做法。也可以使用getOrElse来提供当为None时的默认值。
                        </p>
                        <p>
                            给力的是Option还可以看作是最大长度为1的List，其的强大功能都可以使用。
                        </p>
                        <p>
                            尝试在最后添加 osName.foreach(print _) 。
                        </p>
                    </div>
                </div>
            </div>
            <div class="step slide deeply" data-x="10000" data-y="-500" data-z="-3000">
                <div class="row-fluid">
                    <div class="span8">
                        <div class="workspace">
                            <div class="controls">
                                <button type="button" class="run btn btn-primary" title="Compile and Run">Run</button>
                            </div>
                            <div class="workspace-top">
                                <div class="workspace-editor">
                                    <form>
                                        <textarea class="editor" spellcheck="false">
class ScalaCurrentVersion(val url: String) {
  lazy val source= {
    println("fetching from url...")
    scala.io.Source.fromURL(url).getLines().toList
  }
  lazy val majorVersion = source.find(_.contains("version.major"))
  lazy val minorVersion = source.find(_.contains("version.minor"))
}
val version = new ScalaCurrentVersion("https://raw.github.com/scala/scala/master/build.number")
println("get scala version from " + version.url)
version.majorVersion.foreach(println _)
version.minorVersion.foreach(println _)
</textarea>
                                    </form>
                                </div>
                            </div>
                            <div class="workspace-bottom">
                                <div class="output"></div>
                            </div>
                        </div>
                    </div>
                    <div class="span4">
                        <h2>
                            Lazy
                        </h2>
                        <p>
                            Lazy可以延迟初始化。加上lazy的字段会在第一次访问的时候初始化。
                        </p>
                        <p>
                            这个例子是从github获得Scala的版本号，由于访问网络需要较多时间。
                        </p>
                        <p>
                            如果费尽力气获取到，而调用它的代码却不去访问就会很浪费。
                        </p>
                        <p>
                            可以使用lazy来延迟获取。
                        </p>
                    </div>
                </div>
            </div>
            <div id="concurrency" class="step" data-x="0" data-y="2000" data-scale="2">
                <h2 style="font-size: 200px;">
                    并发
                </h2>
            </div>
            <div class="step slide deeply" data-x="-2000" data-y="1000" data-z="-3000">
                <div class="row-fluid">
                    <div class="span8">
                        <div class="workspace">
                            <div class="controls">
                                <button type="button" class="run btn btn-primary" title="Compile and Run">Run</button>
                            </div>
                            <div class="workspace-top">
                                <div class="workspace-editor">
                                    <form>
                                        <textarea class="editor" spellcheck="false">
import scala.actors.Actor

class EchoServer extends Actor {
  def act = loop {
    react {
      case msg =&gt; println("echo " + msg)
    }
  }
  start
}

val echoServer = new EchoServer
echoServer ! "hi"
</textarea>
                                    </form>
                                </div>
                            </div>
                            <div class="workspace-bottom">
                                <div class="output"></div>
                            </div>
                        </div>
                    </div>
                    <div class="span4">
                        <h2>
                            使用Actor
                        </h2>
                        <p>
                            Actor是Scala的并发模型。Actor是类似线程的实体，有一个邮箱。
                        </p>
                        <p>
                            可以通过重载act来执行，react获取邮箱消息，！向邮箱发送消息。
                        </p>
                        <p>
                            这个例子是一个EchoServer，接受信息并打印。
                        </p>
                    </div>
                </div>
            </div>
            <div class="step slide deeply" data-x="-500" data-y="1000" data-z="-3000">
                <div class="row-fluid">
                    <div class="span8">
                        <div class="workspace">
                            <div class="controls">
                                <button type="button" class="run btn btn-primary" title="Compile and Run">Run</button>
                            </div>
                            <div class="workspace-top">
                                <div class="workspace-editor">
                                    <form>
                                        <textarea class="editor" spellcheck="false">
import scala.actors.Actor._

val echoServer = actor {
  loop {
    react {
      case msg =&gt; println("echo " + msg)
    }
  }
}
echoServer ! "hi"
</textarea>
                                    </form>
                                </div>
                            </div>
                            <div class="workspace-bottom">
                                <div class="output"></div>
                            </div>
                        </div>
                    </div>
                    <div class="span4">
                        <h2>
                            更简化的写法
                        </h2>
                        <p>
                            可以通过更简化的办法声明Actor。
                        </p>
                        <p>
                            导入scala.actors.Actor.中的actor函数。
                        </p>
                        <p>
                            这个函数可以接受一个表达式返回Actor。
                        </p>
                        <p>
                            react和一般的函数不同，他不会返回。需要用loop函数来循环调用它。
                        </p>
                    </div>
                </div>
            </div>
            <div class="step slide deeply" data-x="1000" data-y="1000" data-z="-3000">
                <div class="row-fluid">
                    <div class="span8">
                        <div class="workspace">
                            <div class="controls">
                                <button type="button" class="run btn btn-primary" title="Compile and Run">Run</button>
                            </div>
                            <div class="workspace-top">
                                <div class="workspace-editor">
                                    <form>
                                        <textarea class="editor" spellcheck="false">
import scala.actors.Actor._
import scala.util.Random

def echoServer(name: String) = actor {
  loop {
    react {
      case msg =&gt; println("server" + name + " echo " + msg +
        " by " + Thread.currentThread())
    }
  }
}

val echoServers = (1 to 4).map(x =&gt; echoServer(x.toString))
(1 to 10).foreach(msg =&gt; echoServers(Random.nextInt(4)) ! msg.toString)
</textarea>
                                    </form>
                                </div>
                            </div>
                            <div class="workspace-bottom">
                                <div class="output"></div>
                            </div>
                        </div>
                    </div>
                    <div class="span4">
                        <h2>
                            Actor原理
                        </h2>
                        <p>
                            Actor比线程轻量。在Scala中可以创建数以百万级的Actor。奥秘在于Actor直接可以复用线程。
                        </p>
                        <p>
                            这个例子创建4个Actor，每次调用的时候打印自身线程。
                        </p>
                        <p>
                            可以发现Actor和线程之间没有任何固定的对应关系。
                        </p>
                        <p>
                            一个Actor可以使用多个线程，一个线程也会被多个Actor复用。
                        </p>
                    </div>
                </div>
            </div>
            <div class="step slide deeply" data-x="2500" data-y="1000" data-z="-3000">
                <div class="row-fluid">
                    <div class="span8">
                        <div class="workspace">
                            <div class="controls">
                                <button type="button" class="run btn btn-primary" title="Compile and Run">Run</button>
                            </div>
                            <div class="workspace-top">
                                <div class="workspace-editor">
                                    <form>
                                        <textarea class="editor" spellcheck="false">
import scala.actors.Actor._

val versionUrl = "https://raw.github.com/scala/scala/master/starr.number"

val fromURL = actor {
  loop {
    react {
      case url: String =&gt; reply(scala.io.Source.fromURL(url).getLines().mkString("\n"))
    }
  }
}

val version = fromURL !？ versionUrl
println(version)
</textarea>
                                    </form>
                                </div>
                            </div>
                            <div class="workspace-bottom">
                                <div class="output"></div>
                            </div>
                        </div>
                    </div>
                    <div class="span4">
                        <h2>
                            同步返回
                        </h2>
                        <p>
                            Actor非常适合于较耗时的操作。比如获取网络资源。
                        </p>
                        <p>
                            这个例子通过reply返回，通过!?同步发送并获取消息。使用时类似一个函数调用。
                        </p>
                        <p>
                            将!?修改为!!，可以返回一个future。future是一个函数，可以调用查看结果。
                        </p>
                        <p>
                            将println(version)修改为println(version())
                        </p>
                    </div>
                </div>
            </div>
            <div class="step slide deeply" data-x="4000" data-y="1000" data-z="-3000">
                <div class="row-fluid">
                    <div class="span8">
                        <div class="workspace">
                            <div class="controls">
                                <button type="button" class="run btn btn-primary" title="Compile and Run">Run</button>
                            </div>
                            <div class="workspace-top">
                                <div class="workspace-editor">
                                    <form>
                                        <textarea class="editor" spellcheck="false">
import scala.actors.Actor._
val versionUrl = "https://raw.github.com/scala/scala/master/starr.number"
val fromURL = actor {
  loop {
    react {
      case (url: String, relayer: scala.actors.Actor) =&gt;
        relayer ! scala.io.Source.fromURL(url).getLines().mkString("\n")
    }
  }
}
fromURL ! (versionUrl, actor {
  reactWithin(1000) {
    case msg: String =&gt; println(msg)
    case TIMEOUT =&gt; println("timeout")
  }
})
</textarea>
                                    </form>
                                </div>
                            </div>
                            <div class="workspace-bottom">
                                <div class="output"></div>
                            </div>
                        </div>
                    </div>
                    <div class="span4">
                        <h2>
                            异步返回
                        </h2>
                        <p>
                            异步操作可以最大发挥CPU效能。最佳的办法是在消息中包含需要回调Actor。
                        </p>
                        <p>
                            这个例子通过传入一个actor达到异步调用。
                        </p>
                        <p>
                            当react不在loop中时，有必要使用reactWithin检测超时。
                        </p>
                    </div>
                </div>
            </div>
            <div class="step slide deeply" data-x="5500" data-y="1000" data-z="-3000">
                <div class="row-fluid">
                    <div class="span8">
                        <div class="workspace">
                            <div class="controls">
                                <button type="button" class="run btn btn-primary" title="Compile and Run">Run</button>
                            </div>
                            <div class="workspace-top">
                                <div class="workspace-editor">
                                    <form>
                                        <textarea class="editor" spellcheck="false">
val urls = "http://scala-lang.org" :: "https://github.com/yankay/scala-tour" :: Nil

def fromURL(url: String) = scala.io.Source.fromURL(url).getLines().mkString("\n")

val s = System.currentTimeMillis()
time(urls.map(fromURL(_)))
println("time: " + (System.currentTimeMillis - s) + "ms")
</textarea>
                                    </form>
                                </div>
                            </div>
                            <div class="workspace-bottom">
                                <div class="output"></div>
                            </div>
                        </div>
                    </div>
                    <div class="span4">
                        <h2>
                            并发集合
                        </h2>
                        <p>
                            这个例子是访问若干URL，并记录时间。
                        </p>
                        <p>
                            如果能并发访问，就可以大幅提高性能。
                        </p>
                        <p>
                            尝试将urls.map修改为urls.par.map。这样每个map中的函数都可以并发执行。
                        </p>
                        <p>
                            当函数式和并发结合，就会这样让人兴奋。
                        </p>
                    </div>
                </div>
            </div>
            <div class="step slide deeply" data-x="7000" data-y="1000" data-z="-3000">
                <div class="row-fluid">
                    <div class="span8">
                        <div class="workspace">
                            <div class="controls">
                                <button type="button" class="run btn btn-primary" title="Compile and Run">Run</button>
                            </div>
                            <div class="workspace-top">
                                <div class="workspace-editor">
                                    <form>
                                        <textarea class="editor" spellcheck="false">
val file = List("warn 2013 msg", "warn 2012 msg", "error 2013 msg", "warn 2013 msg")

def wordcount(str: String): Int = str.split(" ").count("msg" == _)

val num = file.par.map(wordcount).par.reduceLeft(_ + _)

println("wordcount:" + num)
</textarea>
                                    </form>
                                </div>
                            </div>
                            <div class="workspace-bottom">
                                <div class="output"></div>
                            </div>
                        </div>
                    </div>
                    <div class="span4">
                        <h2>
                            并发wordcount
                        </h2>
                        <p>
                            这个例子是访问若干URL，并记录时间。
                        </p>
                        <p>
                            并发集合支持大部分集合的功能。
                        </p>
                        <p>
                            在前面有一个wordcount例子，也可以用并发集合加以实现。
                        </p>
                        <p>
                            不增加程序复杂性，却能大幅提高程序利用多核的能力。
                        </p>
                    </div>
                </div>
            </div>
            <div class="step slide deeply" data-x="8500" data-y="1000" data-z="-3000">
                <div class="row-fluid">
                    <div class="span8">
                        <div class="workspace">
                            <div class="controls">
                                <button type="button" class="run btn btn-primary" title="Compile and Run">Run</button>
                            </div>
                            <div class="workspace-top">
                                <div class="workspace-editor">
                                    <form>
                                        <textarea class="editor" spellcheck="false">
import scala.actors.remote.RemoteActor._
import scala.actors.Actor._
import scala.actors.remote.Node
import scala.util.Random
import java.util.Date

val port = 5001 + Random.nextInt(65535 - 5001)

val timeServer = actor {
  alive(port)
  register('timeServer, self)
  loop {
    react {
      case msg =&gt; {
        println(msg)
        reply(System.currentTimeMillis())
      }
    }
  }
}

val timeServerClient = select(Node("127.0.0.1", port), 'timeServer)

timeServer !? "give me time" match {
  case time: Long =&gt; println(new Date(time))
}
</textarea>
                                    </form>
                                </div>
                            </div>
                            <div class="workspace-bottom">
                                <div class="output"></div>
                            </div>
                        </div>
                    </div>
                    <div class="span4">
                        <h2>
                            远程Actor
                        </h2>
                        <p>
                            Actor是并发模型，也使用于分布式。
                        </p>
                        <p>
                            这个例子创建一个时间服务器，通过alive来监听TCP端口，register来注册自己。
                        </p>
                        <p>
                            调用时通过select创建client.其余和普通Actor一样。
                        </p>
                    </div>
                </div>
            </div>
            <div id="practice" class="step" data-x="3000" data-y="0" data-scale="2">
                <h2 style="font-size: 200px;">
                    实践
                </h2>
            </div>
            <div class="step slide deeply" data-x="-2000" data-y="2500" data-z="-3000">
                <div class="row-fluid">
                    <div class="span8">
                        <div class="workspace">
                            <div class="controls">
                                <button type="button" class="run btn btn-primary" title="Compile and Run">Run</button>
                            </div>
                            <div class="workspace-top">
                                <div class="workspace-editor">
                                    <form>
                                        <textarea class="editor" spellcheck="false">
import org.apache.commons.beanutils.BeanUtils
import scala.beans.BeanProperty

class SimpleBean( var name: String) {
}

val bean = new SimpleBean("foo")

println(BeanUtils.describe(bean))
</textarea>
                                    </form>
                                </div>
                            </div>
                            <div class="workspace-bottom">
                                <div class="output"></div>
                            </div>
                        </div>
                    </div>
                    <div class="span4">
                        <h2>
                            使用Java
                        </h2>
                        <p>
                            Scala可以非常方便的互操作，前面已经有大量Scala直接使用Java的例子。
                        </p>
                        <p>
                            同样Java也可以使用Scala。这个例子演示使用@BeanProperty注解来生成Java Style的Bean。
                        </p>
                        <p>
                            尝试将在var name前加上@BeanProperty。这样就给bean添加了getter/setter
                        </p>
                        <p>
                            Apache BeanUtils就可以正常工作。
                        </p>
                    </div>
                </div>
            </div>
            <div class="step slide deeply" data-x="-500" data-y="2500" data-z="-3000">
                <div class="row-fluid">
                    <div class="span8">
                        <div class="workspace">
                            <div class="controls">
                                <button type="button" class="run btn btn-primary" title="Compile and Run">Run</button>
                            </div>
                            <div class="workspace-top">
                                <div class="workspace-editor">
                                    <form>
                                        <textarea class="editor" spellcheck="false">
class Person(val name: String) {
  override def equals(other: Any) = other match {
    case that: Person =&gt; name.equals(that.name)
    case _ =&gt; false
  }
}

println(new Person("Black") == new Person("Black"))
</textarea>
                                    </form>
                                </div>
                            </div>
                            <div class="workspace-bottom">
                                <div class="output"></div>
                            </div>
                        </div>
                    </div>
                    <div class="span4">
                        <h2>
                            相等性
                        </h2>
                        <p>
                            Scala可以非常方便的互操作，前面已经有大量Scala直接使用Java的例子。
                        </p>
                        <p>
                            在Scala中==操作等效于equals，这一点和Java不同。更自然一些。
                        </p>
                        <p>
                            这个例子定义了一个equals函数，并验证。
                        </p>
                        <p>
                            写一个完全正确的equal函数并不容易，这个例子也有子类会不对称的Bug。
                        </p>
                        <p>
                            尝试将class修改为case class并删除equals函数。
                        </p>
                        <p>
                            case类会自动生成正确的equals函数。
                        </p>
                    </div>
                </div>
            </div>
            <div class="step slide deeply" data-x="1000" data-y="2500" data-z="-3000">
                <div class="row-fluid">
                    <div class="span8">
                        <div class="workspace">
                            <div class="controls">
                                <button type="button" class="run btn btn-primary" title="Compile and Run">Run</button>
                            </div>
                            <div class="workspace-top">
                                <div class="workspace-editor">
                                    <form>
                                        <textarea class="editor" spellcheck="false">
object Email {
  def apply(user: String, domain: String) = user + "@" + domain

  def unapply(str: String) = new Regex("""(.*)@(.*)""").unapplySeq(str).get match {
    case user :: domain :: Nil =&gt; Some(user, domain)
    case _ =&gt; None
  }
}

"user@domain.com" match {
  case Email(user, domain) =&gt; println(user + "@" + domain)
}
</textarea>
                                    </form>
                                </div>
                            </div>
                            <div class="workspace-bottom">
                                <div class="output"></div>
                            </div>
                        </div>
                    </div>
                    <div class="span4">
                        <h2>
                            抽取器
                        </h2>
                        <p>
                            Scala可以非常方便的互操作，前面已经有大量Scala直接使用Java的例子。
                        </p>
                        <p>
                            抽取器可以帮助pattern match进行解构。
                        </p>
                        <p>
                            这个例子是构建一个Email抽取器，只要实现unapply函数就可以了。
                        </p>
                        <p>
                            Scala的正则表达式会自带抽取器，可以抽取出一个List。List的元素是匹配()里的表达式。
                        </p>
                        <p>
                            抽取器很有用，短短的例子里就有两处使用抽取器：
                        </p>
                        <p>
                            case user :: domain :: Nil解构List；case Email(user, domain) 解构Email。
                        </p>
                    </div>
                </div>
            </div>
            <div class="step slide deeply" data-x="2500" data-y="2500" data-z="-3000">
                <div class="row-fluid">
                    <div class="span8">
                        <div class="workspace">
                            <div class="controls">
                                <button type="button" class="run btn btn-primary" title="Compile and Run">Run</button>
                            </div>
                            <div class="workspace-top">
                                <div class="workspace-editor">
                                    <form>
                                        <textarea class="editor" spellcheck="false">
import scala.collection.mutable.WeakHashMap
def memo[X, R](f: X =&gt; R) = {
  val cache = new WeakHashMap[X, R]
  (x: X) =&gt; cache.getOrElseUpdate(x, f(x))
}

def fibonacci_(in: Int): Int = in match {
  case 0 =&gt; 0;
  case 1 =&gt; 1;
  case n: Int =&gt; fibonacci_(n - 1) + fibonacci_(n - 2)
}

val fibonacci: Int =&gt; Int = memo(fibonacci_)

val t1 = System.currentTimeMillis()
println(fibonacci(40))
println("it takes " + (System.currentTimeMillis() - t1) + "ms")

val t2 = System.currentTimeMillis()
println(fibonacci(40))
println("it takes " + (System.currentTimeMillis() - t2) + "ms")
</textarea>
                                    </form>
                                </div>
                            </div>
                            <div class="workspace-bottom">
                                <div class="output"></div>
                            </div>
                        </div>
                    </div>
                    <div class="span4">
                        <h2>
                            记忆模式
                        </h2>
                        <p>
                            Scala可以非常方便的互操作，前面已经有大量Scala直接使用Java的例子。
                        </p>
                        <p>
                            记忆模式可以解决手动编写存取cache代码的麻烦。
                        </p>
                        <p>
                            这个例子中，memo可以将一个不含cache函数，包装成一个含有cache功能的。
                        </p>
                        <p>
                            还是斐波那契的例子，通过cache可以使性能提高。
                        </p>
                        <p>
                            尝试将fibonacci_(n - 1) + fibonacci_(n - 2)修改fibonacci(n - 1) + fibonacci(n - 2)，可以提高更多。
                        </p>
                    </div>
                </div>
            </div>
            <div class="step slide deeply" data-x="4000" data-y="2500" data-z="-3000">
                <div class="row-fluid">
                    <div class="span8">
                        <div class="workspace">
                            <div class="controls">
                                <button type="button" class="run btn btn-primary" title="Compile and Run">Run</button>
                            </div>
                            <div class="workspace-top">
                                <div class="workspace-editor">
                                    <form>
                                        <textarea class="editor" spellcheck="false">
implicit def strToDate(str: String) = new SimpleDateFormat("yyyy-MM-dd").parse(str)

println("2013-01-01 unix time: " + "2013-01-01".getTime()/1000l)
</textarea>
                                    </form>
                                </div>
                            </div>
                            <div class="workspace-bottom">
                                <div class="output"></div>
                            </div>
                        </div>
                    </div>
                    <div class="span4">
                        <h2>
                            隐式转换
                        </h2>
                        <p>
                            implicit可以定义一个转换函数，可以在下面的使用到的时候自动转换。
                        </p>
                        <p>
                            这个例子可以将String自动转换为Date类型。隐式转换时实现DSL的重要工具。
                        </p>
                    </div>
                </div>
            </div>
            <div class="step slide deeply" data-x="5500" data-y="2500" data-z="-3000">
                <div class="row-fluid">
                    <div class="span8">
                        <div class="workspace">
                            <div class="controls">
                                <button type="button" class="run btn btn-primary" title="Compile and Run">Run</button>
                            </div>
                            <div class="workspace-top">
                                <div class="workspace-editor">
                                    <form>
                                        <textarea class="editor" spellcheck="false">
import org.json4s._
import org.json4s.JsonDSL._

import org.json4s.jackson.JsonMethods._

case class Twitter(id: Long, text: String, publishedAt: Option[java.util.Date])

var twitters = Twitter(1, "hello scala", Some(new Date())) :: Twitter(2, "I like scala tour", None) :: Nil

var json = ("twitters"
  -&gt; twitters.map(
    t =&gt; ("id" -&gt; t.id)
      ~ ("text" -&gt; t.text)
      ~ ("published_at" -&gt; t.publishedAt.toString())))

println(pretty(render(json)))
</textarea>
                                    </form>
                                </div>
                            </div>
                            <div class="workspace-bottom">
                                <div class="output"></div>
                            </div>
                        </div>
                    </div>
                    <div class="span4">
                        <h2>
                            DSL
                        </h2>
                        <p>
                            DSL是Scala最强大武器，Scala可以使一些描述性代码变得极为简单。
                        </p>
                        <p>
                            这个例子是使用DSL生成JSON。Scala很多看似是语言级的特性也是用DSL做到的。
                        </p>
                        <p>
                            自己编写DSL有点复杂，但使用方便灵活的。
                        </p>
                    </div>
                </div>
            </div>
            <div class="step slide deeply" data-x="7000" data-y="2500" data-z="-3000">
                <div class="row-fluid">
                    <div class="span8">
                        <div class="workspace">
                            <div class="controls">
                                <button type="button" class="run btn btn-primary" title="Compile and Run">Run</button>
                            </div>
                            <div class="workspace-top">
                                <div class="workspace-editor">
                                    <form>
                                        <textarea class="editor" spellcheck="false">
import org.specs2.mutable._

class FactorialSpec extends Specification {
  args.report(color = false)

  def factorial(n: Int) = (1 to n).reduce(_ * _)

  "The 'Hello world' string" should {
    "factorial 3 must be 6" in {
      factorial(3) mustEqual 6
    }
    "factorial 4 must be 6" in {
      factorial(4) must greaterThan(6)
    } 
  }
}
specs2.run(new FactorialSpec)
</textarea>
                                    </form>
                                </div>
                            </div>
                            <div class="workspace-bottom">
                                <div class="output"></div>
                            </div>
                        </div>
                    </div>
                    <div class="span4">
                        <h2>
                            测试
                        </h2>
                        <p>
                            Scala DSL可以使测试更方便。
                        </p>
                        <p>
                            这个例子是测试一个阶乘函数。使用should/in来建立测试用例。
                        </p>
                        <p>
                            测试是默认并发执行的。
                        </p>
                    </div>
                </div>
            </div>
            <div class="step slide deeply" data-x="8500" data-y="2500" data-z="-3000">
                <div class="row-fluid">
                    <div class="span8">
                        <div class="workspace">
                            <div class="controls">
                                <button type="button" class="run btn btn-primary" title="Compile and Run">Run</button>
                            </div>
                            <div class="workspace-top">
                                <div class="workspace-editor">
                                    <form>
                                        <textarea class="editor" spellcheck="false">
#Linux/Mac:
git clone https://github.com/yankay/scala-tour-zh.git
cd scala-tour-zh
./sbt/sbt run

#Windows
git clone https://github.com/yankay/scala-tour-zh.git
cd scala-tour-zh
sbt\sbt run
</textarea>
                                    </form>
                                </div>
                            </div>
                            <div class="workspace-bottom">
                                <div class="output"></div>
                            </div>
                        </div>
                    </div>
                    <div class="span4">
                        <h2>
                            Simple Build Tool
                        </h2>
                        <p>
                            SBT是Scala的最佳编译工具，在他的帮助下，
                        </p>
                        <p>
                            你甚至不需要安装除JRE外的任何东西，来开发Scala。
                        </p>
                        <p>
                            例如你想在自己的机器上执行这个Scala-Tour
                        </p>
                    </div>
                </div>
            </div>
            <div id="about" class="step" data-x="3750" data-y="2500" data-scale="1">
                <h2>
                    About
                </h2>
            </div>
        </div>
        <div class="hint">
            <p>
                Use a spacebar or arrow keys to navigate
            </p>
        </div><script>
if ("ontouchstart" in document.documentElement) { 
        document.querySelector(".hint").innerHTML = "<p>Tap on the left or right to navigate<\/p>";
        }
        </script> <script src="js/jquery.min.js">
</script> <script src="js/impress.js">
</script> <script src="js/bootstrap.js">
</script> <script>
document.getElementById("body").className=document.getElementById("body").className.replace('onload',' ');
        impress().init();
        </script> <script src="js/codemirror.min.js">
</script> <script src="js/matchbrackets.js">
</script> <script src="js/clike.js">
</script> <script src="js/scala-tour.js">
</script>
        <div style="position: fixed; bottom: 0px; left: 10px; pointer-events: auto; width:100%;">
            <div class="container" style="width:1024px">
                <!--
                <iframe src="http://ghbtns.com/github-btn.html?user=yankay&amp;repo=scala-tour&amp;type=watch&amp;count=true" allowtransparency="true" frameborder="0" scrolling="0" width="110px" height="20px"></iframe> <iframe src="http://ghbtns.com/github-btn.html?user=yankay&amp;repo=scala-tour&amp;type=fork&amp;count=true" allowtransparency="true" frameborder="0" scrolling="0" width="110px" height="20px"></iframe>
            -->
            </div>
        </div>
    </body>
</html>
